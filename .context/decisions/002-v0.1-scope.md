# arcitect — v0.1 scope and worktree plan

*established: 2026-02-19*

## v0.1 goal

a usable map annotation tool for ARC Raiders. user can open maps, draw paths, place tokens, add annotations, log runs, and have everything persist locally. this is the "I can actually use this while playing" milestone.

## what ships in v0.1

| US | feature | v0.1 scope | deferred |
|----|---------|------------|----------|
| US-1 | map switching | all 6 maps + practice range in sidebar | map list auto-update from remote |
| US-2 | pre-annotated layers | at minimum 2-3 layer types per map (extractions, loot zones, enemy spawns) | full POI coverage, community data sync |
| US-3 | run path drawings | freehand draw with color picker, save per run | run path history overlay, path labeling |
| US-4 | custom annotations | text, rect, circle, arrow, freehand. select/move/resize/delete. | grouping, opacity slider, lock |
| US-5 | run value tracking | run logger form with map, outcome, value, duration, notes | aggregate stats, charts |
| US-6 | custom tokens | loot/enemy/death/pvp stamps with notes | subtype dropdown from game data, filtering panel |
| US-7 | sharing | **deferred entirely** | clipboard + file export |
| US-8 | state storage | sqlite in $APPDATA, all state persists across sessions | backup/export |
| US-9 | map navigation | wheel zoom, click-drag pan, keyboard shortcuts, trackpad pinch | minimap, double-click zoom-to-fit |

## v0.1 user experience

```
1. open app → dark-themed frameless window, map selector in sidebar
2. select "Dam Battlegrounds" → map loads, centered, zoomable
3. toggle POI layers → extraction points appear/disappear
4. switch to draw mode → freehand draw a route in red
5. switch to token mode → place a death skull where I died
6. add a text annotation → "sniper nest, avoid"
7. select and move the text → drag it to the right spot
8. log a run → fill in map, outcome: died, value: 12,400, notes: "got ambushed at extraction"
9. close app → reopen → everything is exactly where I left it
10. switch to "Buried City" → clean map, ready for annotation
11. switch back to "Dam Battlegrounds" → all my annotations still there
```

---

## worktree decomposition

the work breaks into 4 independent workstreams that can run as parallel worktrees after a shared scaffold phase. each workstream touches different directories to minimize merge conflicts.

### phase 0: scaffold (sequential, single session — must complete first)

**branch:** `main`
**purpose:** create the project skeleton that all worktrees branch from

- [ ] `create-tauri-app` with react + typescript template
- [ ] install core dependencies:
  - fabric.js
  - tailwind CSS + postcss + autoprefixer
  - shadcn/ui (react)
  - @tauri-apps/plugin-sql
  - @tauri-apps/plugin-fs
  - lucide-react (icons)
- [ ] install dev/infrastructure dependencies:
  - eslint + prettier (TS/React linting + formatting)
  - eslint-config-prettier (disable conflicting rules)
  - @typescript-eslint/eslint-plugin + parser
  - vitest + @testing-library/react + jsdom (frontend testing)
  - @tauri-apps/api/mocks (tauri IPC mocking for tests)
  - husky + lint-staged (git hook enforcement)
- [ ] configure tauri:
  - frameless window (`decorations: false`)
  - $APPDATA permissions
  - sql plugin + fs plugin in capabilities
- [ ] configure linting + formatting:
  - eslint config: typescript-eslint recommended + react hooks rules + prettier
  - prettier config: consistent style (single quotes, trailing commas, etc.)
  - `.eslintignore` / `.prettierignore` for generated files, dist, etc.
- [ ] configure rust tooling:
  - `rustfmt.toml` in src-tauri/ (or use defaults)
  - clippy lints in `Cargo.toml` or `clippy.toml`
- [ ] configure git hooks (husky + lint-staged):
  - pre-commit: lint-staged runs eslint --fix + prettier --write on staged .ts/.tsx/.js files
  - pre-commit: cargo fmt --check + cargo clippy on staged .rs files
  - hooks enforced for all sessions (human and agent)
- [ ] configure testing:
  - vitest config (vitest.config.ts): jsdom environment, path aliases matching tsconfig
  - test directory structure: `src/**/*.test.ts(x)` co-located with source
  - tauri mock setup helper for tests that call IPC
  - `cargo test` configuration in src-tauri/
  - npm scripts: `test`, `test:watch`, `lint`, `lint:fix`, `format`
- [ ] configure release pipeline:
  - `.github/workflows/publish.yml`: tauri-apps/tauri-action@v0
  - matrix strategy: macos-latest (arm64 + x86_64) + windows-latest
  - trigger: push tag `v*` or manual workflow_dispatch
  - artifacts: .dmg (macOS), .msi + NSIS .exe (Windows)
  - releaseDraft: true (review before publishing)
  - no code signing for v0.1 (users click through OS warnings)
- [ ] set up project directory structure:
  ```
  src/
  ├── components/
  │   ├── canvas/        # worktree A territory
  │   ├── layout/        # worktree C territory
  │   ├── panels/        # worktree C territory
  │   └── ui/            # shadcn components (shared)
  ├── hooks/             # worktree A territory
  ├── lib/
  │   ├── api/           # worktree B territory
  │   ├── db/            # worktree B territory
  │   └── types/         # shared types (define early)
  ├── stores/            # worktree B + C shared
  ├── styles/            # worktree C territory
  ├── App.tsx
  └── main.tsx
  src-tauri/
  ├── src/
  │   └── lib.rs         # worktree B territory
  ├── migrations/        # worktree B territory
  ├── capabilities/
  └── tauri.conf.json
  data/
  ├── maps/              # worktree D territory
  ├── game-data/         # worktree D territory
  └── icons/             # worktree D territory
  ```
- [ ] define shared TypeScript types in `src/lib/types/`:
  ```typescript
  // types that all worktrees need to agree on
  interface ArcMap { id: string; name: string; imageFilename: string; ... }
  interface Run { id: string; mapId: string; outcome: string; ... }
  interface Annotation { id: string; mapId: string; type: string; ... }
  interface Token { id: string; mapId: string; tokenType: string; ... }
  interface RunPath { id: string; runId: string; color: string; ... }
  ```
- [ ] create placeholder components so worktrees have import targets
- [ ] initial commit, push to remote
- [ ] create worktree branches: `feature/canvas-engine`, `feature/data-layer`, `feature/ui-shell`, `feature/game-data`

**estimate:** ~1 session

---

### worktree A: `feature/canvas-engine`

**directory territory:** `src/components/canvas/`, `src/hooks/useCanvas*`, `src/hooks/useMapNavigation*`
**depends on:** phase 0 (types, fabric.js installed)
**no dependency on:** worktrees B, C, D (uses mock data / test map image)

**scope:**
- [ ] fabric.js canvas initialization (useRef + useEffect pattern)
- [ ] map image loading and display (background, locked, non-selectable)
- [ ] zoom/pan navigation (US-9):
  - mouse wheel zoom centered on cursor
  - click-drag pan
  - trackpad pinch-to-zoom
  - keyboard shortcuts (+/-, arrows, Home)
  - zoom min/max bounds
- [ ] mode manager (navigate / draw / token / select)
  - cursor changes per mode
  - mode switching doesn't conflict with navigation
- [ ] freehand drawing mode (US-3):
  - enter draw mode → fabric.js isDrawingMode
  - color picker integration
  - completed paths get metadata (layerGroup, runId)
- [ ] annotation tools (US-4):
  - text placement (IText with in-place editing)
  - rectangle tool
  - circle tool
  - arrow tool (Line + Triangle or custom)
  - select mode: drag, resize, rotate, delete
- [ ] token placement mode (US-6):
  - click to place token icon at position
  - token type determines icon/color
  - tokens get metadata (tokenType, position)
- [ ] layer visibility management:
  - show/hide by layerGroup + layerId
  - object metadata filtering
- [ ] canvas state serialization helpers:
  - serialize annotations/tokens/paths to JSON for persistence
  - deserialize and reconstruct canvas from saved state
- [ ] canvas events/callbacks:
  - expose onAnnotationCreated, onTokenPlaced, onPathDrawn callbacks
  - these will be wired to the data layer after merge

**test with:** single hardcoded map image, in-memory state only
**unit tests:** vitest tests for serialization helpers, mode manager logic, layer filtering
**outputs:** `<MapCanvas />` component with full drawing/annotation capability, ready to connect to real data

---

### worktree B: `feature/data-layer`

**directory territory:** `src-tauri/src/`, `src-tauri/migrations/`, `src/lib/api/`, `src/lib/db/`
**depends on:** phase 0 (types, tauri plugins configured)
**no dependency on:** worktrees A, C, D

**scope:**
- [ ] sqlite schema creation (from data-model.md):
  - migration 001: maps, map_layers, map_pois tables
  - migration 002: runs table
  - migration 003: run_paths, annotations, tokens tables
  - migration 004: settings, schema_version tables
  - migration 005: indexes
- [ ] tauri-plugin-sql integration:
  - database initialization on app start
  - migration runner
  - connection management
- [ ] data access layer (TypeScript API wrappers):
  - `src/lib/db/maps.ts` — getMaps(), getMapById(), getLayersForMap(), getPoisForLayer()
  - `src/lib/db/runs.ts` — createRun(), getRuns(), getRunsByMap(), updateRun(), deleteRun()
  - `src/lib/db/annotations.ts` — saveAnnotation(), getAnnotationsForMap(), updateAnnotation(), deleteAnnotation()
  - `src/lib/db/tokens.ts` — saveToken(), getTokensForMap(), getTokensByType(), deleteToken()
  - `src/lib/db/paths.ts` — saveRunPath(), getPathsForRun(), getPathsForMap(), deletePath()
  - `src/lib/db/settings.ts` — getSetting(), setSetting()
- [ ] seed data loader:
  - on first launch, populate maps table from bundled game data
  - on first launch, populate map_layers and map_pois from bundled POI data
  - version check: only re-seed if game data version changes
- [ ] react hooks for data access:
  - `useMaps()`, `useRuns(mapId)`, `useAnnotations(mapId)`, `useTokens(mapId)`
  - these wrap the db functions with loading/error state

**test with:** unit tests against sqlite in-memory, no UI needed
**unit tests:** vitest tests for all CRUD functions using @tauri-apps/api/mocks, cargo tests for any rust-side logic
**outputs:** complete data layer API that the UI and canvas can call

---

### worktree C: `feature/ui-shell`

**directory territory:** `src/components/layout/`, `src/components/panels/`, `src/styles/`, `src/App.tsx`
**depends on:** phase 0 (shadcn/ui installed, tailwind configured)
**no dependency on:** worktrees A, B, D (uses mock data, placeholder canvas)

**scope:**
- [ ] app layout:
  - frameless window with custom title bar (drag region + window controls)
  - sidebar (collapsible) + main content area
  - toolbar above main content
- [ ] dark tactical theme:
  - tailwind config: custom color palette (dark grays, muted accents)
  - shadcn/ui theme overrides for dark mode
  - typography: Inter or Geist font
  - sharp edges, minimal border-radius (tactical feel)
- [ ] map selector panel (sidebar):
  - list of maps with thumbnails/icons
  - active map highlight
  - click to switch
- [ ] layer toggle panel (sidebar or overlay):
  - checkboxes per POI layer
  - group by layer type
  - "show all" / "hide all" shortcuts
- [ ] toolbar:
  - mode buttons: navigate, draw, text, shape, token
  - color picker (for draw mode)
  - token type selector (for token mode)
  - undo/redo buttons (nice-to-have for v0.1)
- [ ] run logger panel:
  - form: map (pre-selected from current), outcome (dropdown), value (number input), duration (number input), notes (textarea)
  - submit saves run to data layer
  - validation: map and outcome required
- [ ] run history panel:
  - list of runs for current map, sorted by date
  - shows: date, outcome, value, duration
  - click to highlight run's paths on canvas (wired after merge)
- [ ] token filter panel (nice-to-have for v0.1):
  - toggle visibility by token type

**test with:** mock data, placeholder `<div>` where canvas will go
**unit tests:** vitest tests for form validation, panel state logic, theme rendering
**outputs:** complete app shell with all panels, forms, and theme — ready to drop in real canvas and data

---

### worktree D: `feature/game-data`

**directory territory:** `data/`, `scripts/`
**depends on:** phase 0 (project exists)
**no dependency on:** worktrees A, B, C

**scope:**
- [ ] clone RaidTheory/arcraiders-data, inspect JSON schema
- [ ] write data transformation scripts:
  - parse item/weapon/gear data into arcitect's schema
  - extract map metadata (names, unlock requirements, round durations)
  - structure POI data per map (extraction points, loot zones, enemy spawns)
- [ ] source map images:
  - investigate FModel extraction from UE5 files
  - alternatively: use community map images with proper attribution
  - prepare images: consistent resolution, named per map_id
  - placeholder images if real ones aren't ready
- [ ] create bundled data files:
  - `data/game-data/maps.json` — map metadata
  - `data/game-data/layers/` — per-map POI layer JSON
  - `data/game-data/items.json` — item database (for token subtypes later)
  - `data/maps/` — map image files
- [ ] create token icon set:
  - loot icon (gold/yellow)
  - enemy icon (red)
  - death icon (skull)
  - pvp icon (crossed swords)
  - custom icon (pin/star)
  - SVG or PNG at consistent size
- [ ] document data update process:
  - how to refresh from upstream when game updates
  - versioning scheme for bundled data

**test with:** visual inspection of output JSON, image quality check
**outputs:** complete bundled data package ready to be seeded into sqlite

---

## merge order

```
main (scaffold)
  ├── feature/game-data     →  merge first (no code deps, just data files)
  ├── feature/data-layer    →  merge second (depends on game-data for seed data)
  ├── feature/canvas-engine →  merge third (standalone, but wiring needs data layer)
  └── feature/ui-shell      →  merge fourth (needs canvas + data to wire up)

  → integration session: wire canvas ↔ data ↔ UI together
  → v0.1 release
```

## integration phase (after all worktrees merge)

this is a single session after merging all branches:

- [ ] wire canvas events to data layer (onAnnotationCreated → saveAnnotation, etc.)
- [ ] wire UI panels to data layer (map selector → loadMap, run form → createRun)
- [ ] wire UI controls to canvas (mode buttons → canvas mode, color picker → brush color)
- [ ] load persisted state on map switch (annotations, tokens, paths from sqlite → canvas)
- [ ] save state on canvas changes (canvas → sqlite)
- [ ] end-to-end test: create annotations, close app, reopen, verify persistence
- [ ] verify all tests pass: `npm test` (vitest) + `cargo test` (rust)
- [ ] verify linting clean: `npm run lint` + `cargo clippy`
- [ ] verify release build: `npm run tauri build` succeeds on dev machine
- [ ] tag v0.1.0, push tag to trigger publish workflow, verify draft release created with artifacts
- [ ] polish: fix visual inconsistencies, adjust theme, test on both platforms

## what's explicitly NOT in v0.1

- sharing / export (US-7) — v0.2
- run path history overlay with toggle per run — v0.2
- aggregate run stats / charts — v0.2
- token subtype dropdown from game data — v0.2
- token filtering panel — v0.2
- minimap viewport indicator — v0.2
- annotation grouping / locking / opacity — v0.2
- data sync from remote game data updates — v0.2
- WebDriver E2E tests (macOS has no WKWebView WebDriver — revisit Q2 2026) — v0.2
- code signing / notarization (users click through OS warnings for now) — v0.2
- heatmap visualization of token density — v0.3+
- OCR/screenshot run data import — v0.3+
